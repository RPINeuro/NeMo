#include "neuro_event_handlers.h"

/**
 * Neuro event handlers. Contains the forwad, reverse, and init functions for 
 * neurons defined in the model.
 */

 
 void neuron_init(neuronState *s, tw_lp *lp) {
 	switch (s->neuronType) {
 		case TrueNorth:
 			IBM_neuron_init(s, lp);
 			break;
 		}




 	}
 /** \ingroup IBMFunctions
  *  IBM Neuron Functions 
  * @{ */

 void IBM_neuron_init(neuronState *s, tw_lp *lp){
    static int pairedNeurons = 0;
    static bool announced = false;
    s->neuronTypeDesc = "SIMPLE";
    if(DEBUG_MODE && !announced)
        printf("Creating neurons\n");
    	announced = true;
    //ADD FILE INPUT NEURON CREATION HERE
    
    
    IBM_create_simple_neuron(s, lp);

    //createDisconnectedNeuron(s, lp);



    if (DEBUG_MODE) {
        printf("Neuron type %s, num: %llu checking in with GID %llu and dest %llu \n",
         s->neuronTypeDesc, s->myLocalID, lp->gid, s->outputGID);
    }
}

/**
 * @brief      Creates a simple neuron for a identity matrix benchmark.
 *  Weights are set up such that axon $n$ has weight 1, where $n$ is the 
 *  neuron local id. Other axons have weight 0. Leak is set to zero as well.
 *  The output axon is a randomly selected axon.
 * 
 *
 * @param      s     { parameter_description }
 * @param      lp    The pointer to a
 */
void IBM_create_simple_neuron(neuronState *s, tw_lp *lp){
    //Rewrote this function to have a series of variables that are easier to read.
    //Since init time is not so important, readability wins here.
    //AutoGenerated test neurons:
    bool synapticConnectivity[NEURONS_IN_CORE];
    short G_i[NEURONS_IN_CORE];
    short sigma[4];
    short S[4] = {[0]=3} ;
    bool b[4];
    bool epsilon = 0;
    bool sigma_l = 0;
    short lambda = 0;
    bool c = false;
    short TM = 0;
    short VR = 0;
    short sigmaVR = 1;
    short gamma = 0;
    bool kappa = 0;
    int signalDelay = 1;//tw_rand_integer(lp->rng, 0,5);



    for(int i = 0; i < NEURONS_IN_CORE; i ++) {
        //s->synapticConnectivity[i] = tw_rand_integer(lp->rng, 0, 1);
        s->axonTypes[i] = 1;
        G_i[i] = 0;
        synapticConnectivity[i] = 0;
        //synapticConnectivity[i] = tw_rand_integer(lp->rng, 0, 1)
    }

    synapticConnectivity[lGetNeuNumLocal(lp->gid)] = 1;

    //(creates an "ident. matrix" of neurons.
    for(int i = 0; i < 4; i ++){
        //int ri = tw_rand_integer(lp->rng, -1, 0);
        //unsigned int mk = tw_rand_integer(lp->rng, 0, 1);

        //sigma[i] = (!ri * 1) + (-1 & ri))
        //sigma[i] = (mk ^ (mk - 1)) * 1;
        sigma[i] = 1;
        b[i] = 0;
    }


    //weight_type alpha = tw_rand_integer(lp->rng, THRESHOLD_MIN, THRESHOLD_MAX);
    //weight_type beta = tw_rand_integer(lp->rng, (NEG_THRESH_SIGN * NEG_THRESHOLD_MIN), NEG_THRESHOLD_MAX);
    weight_type alpha = 1;
    weight_type beta = -1;
    //DEBUG LINE

    IBMinitNeuronEncodedRV(lGetCoreFromGID(lp->gid), lGetNeuNumLocal(lp->gid), synapticConnectivity,
            G_i, sigma, S, b, epsilon, sigma_l, lambda, c, alpha, beta,
            TM, VR, sigmaVR, gamma, kappa, s, signalDelay,0,0);
    //we re-define the destination axons here, rather than use the constructor.

    float remoteCoreProbability = .905;

    //This neuron's core is X. There is a 90.5% chance that my destination will be X - and a 10% chance it will be a different core.
    if(tw_rand_unif(lp->rng) < remoteCoreProbability){
        //		long dendriteCore = s->myCoreID;
        //		dendriteCore = tw_rand_integer(lp->rng, 0, CORES_IN_SIM - 1);
        s->dendriteCore =  tw_rand_integer(lp->rng, 0, CORES_IN_SIM - 1);
    }else {
        s->dendriteCore = s->myCoreID; //local connection.
    }

    /**@note This random setup will create neurons that have an even chance of getting an axon inside thier own core
     * vs an external core. The paper actually capped this value at something like 20%. @todo - make this match the
     * paper if performance is slow. * */
    //s->dendriteCore = tw_rand_integer(lp->rng, 0, CORES_IN_SIM - 1);
    s->dendriteLocal = s->myLocalID;// tw_rand_integer(lp->rng, 0, AXONS_IN_CORE - 1);
    //     if (tnMapping == LLINEAR) {
    s->dendriteGlobalDest = lGetAxonFromNeu(s->dendriteCore, s->dendriteLocal);

    if (s->dendriteGlobalDest != lGetAxonFromNeu(s->dendriteCore,s->dendriteLocal))
    {

        tw_error(TW_LOC,"Invalid Axon Destination - neuron %i set gid %i",lp->gid,s->dendriteGlobalDest);
    }
    //     }
    //     else {
    //     s->dendriteGlobalDest = getAxonGlobal(s->dendriteCore, s->dendriteLocal);
    //     }



}

/** Constructor / Init a new neuron. assumes that the reset voltage is NOT encoded (i.e.,
  * a reset value of -5 is allowed. Sets reset voltage sign from input reset voltage).*/
void IBMinitNeuron(id_type coreID, id_type nID,
                bool synapticConnectivity[NEURONS_IN_CORE],
                short G_i[NEURONS_IN_CORE], short sigma[4],
                short S[4], bool b[4], bool epsilon,
                short sigma_l, short lambda, bool c, uint32_t alpha,
                uint32_t beta, short TM, short VR, short sigmaVR, short gamma,
                bool kappa, neuronState *n, int signalDelay, uint64_t destGlobalID,int destAxonID)
{

    for(int i = 0; i < 4; i ++) {

      n->synapticWeight[i] = sigma[i] * S[i];
      n->weightSelection[i] = b[i];
    }
    for(int i = 0; i < NEURONS_IN_CORE; i ++) {
      n->synapticConnectivity[i] = synapticConnectivity[i];
      n->axonTypes[i] = G_i[i];
    }

    //set up other parameters
    n->myCoreID = coreID;
    n->myLocalID = nID;
    n->epsilon = epsilon;
    n->sigma_l = sigma_l;
    n->lambda = lambda;
    n->c = c;
    n->posThreshold = alpha;
    n->negThreshold = beta;
    //n->thresholdMaskBits = TM;
    //n->thresholdPRNMask = getBitMask(n->thresholdMaskBits);
    n->sigmaVR = SGN(VR);
    n->encodedResetVoltage = VR;
    n->resetVoltage = VR; //* sigmaVR;

    n->resetMode = gamma;
    n->kappa = kappa;
    n->omega = 0;

    //! @TODO: perhaps calculate if a neuron is self firing or not.
    n->firedLast = false;
    n->heartbeatOut = false;
    //n->isSelfFiring = false;
    //n->receivedSynapseMsgs = 0;

    IBMsetNeuronDest(signalDelay, destGlobalID, n);

    //synaptic neuron setup:
    n->largestRandomValue = n->thresholdPRNMask;
    if(n->largestRandomValue > 256) {
        tw_error(TW_LOC, "Error - neuron (%i,%i) has a PRN Max greater than 256\n ", n->myCoreID, n->myLocalID);
    }
    //just using this rather than bit shadowing.


    n->dendriteLocal = destAxonID;
    n->dendriteGlobalDest = destGlobalID;

    //Check to see if we are a self-firing neuron. If so, we need to send heartbeats every big tick.
    n->isSelfFiring = false; //!@TODO: Add logic to support self-firing (spontanious) neurons

}
void IBMinitNeuronEncodedRV(id_type coreID, id_type nID,
                         bool synapticConnectivity[NEURONS_IN_CORE],
                         short G_i[NEURONS_IN_CORE], short sigma[4],
                         short S[4], bool b[4], bool epsilon,
                         short sigma_l, short lambda, bool c, uint32_t alpha,
                         uint32_t beta, short TM, short VR, short sigmaVR, short gamma,
                         bool kappa, neuronState *n, int signalDelay, uint64_t destGlobalID,int destAxonID) {

    IBMinitNeuron(coreID, nID, synapticConnectivity, G_i,  sigma, S, b, epsilon,
               sigma_l, lambda, c, alpha, beta,  TM,  VR,  sigmaVR,  gamma,
                kappa,  n,  signalDelay, destGlobalID, destAxonID);
    n->sigmaVR = sigmaVR;
    n->encodedResetVoltage = VR;
    n->resetVoltage = (n->sigmaVR * (pow(2, n->encodedResetVoltage)-1));

}


/*@}*/